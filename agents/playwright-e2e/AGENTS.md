# AGENTS – E2E Testing with Playwright

This document defines the **E2E test writing rules** that AI agents must follow when using
**Playwright Test + Playwright Test Agents (planner / generator / healer)** in web applications based on **Next.js (App Router)**.

Core Objectives:

1. Create stable E2E tests based on **TODO scenario documents** (natural language) written by humans.
2. Leverage the standard workflow of **Playwright Test Agents**
   - Utilize planner → generator → healer to maximize the
     **test plan → test code → healing on failure** loop.
3. Tests always prioritize the **user perspective (User journey)**.
   Do not unnecessarily depend on implementation details (internal functions, DB structure, etc.).

---

## 1. Basic Environment & Directory Conventions

### 1.1 Tech Stack

- Framework: **Next.js (App Router)**
- Test Runner: `@playwright/test`
- Playwright Test Agents: **planner / generator / healer**
- Language: TypeScript
- Browsers: Concurrent execution of Chromium, Firefox, and WebKit
- MCP: `@playwright/mcp` (for browser control in IDE/agents)

### 1.2 Directory Conventions

> If the actual repository already has a Playwright Agents base structure, prioritize that structure.
> (Example: structure generated by `npx playwright init-agents --loop=claude`)

Basic structure (example):

```txt
repo/
  .github/
    agents/                  # Agent definitions generated by init-agents (planner/generator/healer)
  specs/                     # Official test plan generated by planner
    basic-operations.md
  e2e/
    specs/                   # TODO scenario documents written by humans
      posts/
        post-detail.todo.md
        post-like.todo.md
      home/
        home.todo.md
    tests/                   # Actual Playwright test code
      posts/
        post-like-guest.spec.ts
        post-like-member.spec.ts
      home/
        home-guest.spec.ts
    fixtures/
      auth.fixtures.ts
    page-objects/
      post-list.page.ts
      post-detail.page.ts
  tests/                     # (Coexists if Playwright default tests directory already exists)
    seed.spec.ts             # Seed test (used by planner/generator)
  playwright.config.ts
```

- **Playwright Agents Standard**:

  - planner: Create Markdown test plan in `specs/*.md`
  - generator: Generate `tests/*.spec.ts` (or subdirectories depending on configuration)

- **Additional Rules for This Project**:

  - Human-written TODO documents: `e2e/specs/{feature}/**.todo.md`
  - Final E2E test code: `e2e/tests/{feature}/**.spec.ts`
  - **specs and tests maintain the same folder structure** (Example: `e2e/specs/posts/` ↔ `e2e/tests/posts/`)

---

## 2. TODO Document-Based Workflow

### 2.1 TODO Document Format Written by Humans

TODO documents are written on a **page basis** or **feature basis**.

Example: `e2e/specs/post-detail.todo.md`

```md
# /posts/[id] Detail Page - Like Feature

[Scenario 1] Guest user clicks like on the first post

1. Access /posts page as a guest user.
2. Click the first post card in the list to navigate to the detail page.
3. Click the like button (heart icon).
4. A login prompt modal appears, and the text "Login is required for this feature." is displayed.

[Scenario 2] Logged-in member clicks like on the first post

1. Access /posts page while logged in with a test account.
2. Click the first post card in the list to navigate to the detail page.
3. Click the like button, and the like count increases by +1.
4. After refresh, the like status and count are maintained.
```

Rules:

- Each `[Scenario N]` describes **one user journey**.
- Each step can naturally mix "user actions" and "expected results".
- For cases with data dependencies like "first post", it is recommended to write based on fixed data that always exists.

### 2.2 Relationship Between Agents and TODO Documents

Agents use TODO documents as follows:

- **planner**

  - References both `e2e/specs/*.todo.md` and the actual app to
    generate/enhance Markdown test plans (`specs/*.md`) in Playwright standard format.
  - Does **not overwrite** the human-written TODO content, but
    reorganizes scenarios in a more structured manner (separating sections/expected results, etc.).

- **generator**

  - Based on `specs/*.md` (planner output),
    creates `e2e/tests/**.spec.ts` files.

- **healer**

  - Re-runs and analyzes failed `e2e/tests/**.spec.ts`,
    fixes locator/timing/data issues to recover tests.

---

## 3. Planner Agent Rules

### 3.1 Input

- Natural language request: Example) `"Create a plan for the guest/member like flow"`
- Required: **seed test** file (Example: `tests/seed.spec.ts`)
- Optional:

  - Related TODO document (`e2e/specs/post-detail.todo.md`)
  - Related PRD / design document

### 3.2 Operation Rules

1. **Run seed test**

   - Follow the seed test structure provided by Playwright.
   - In this project, seed test typically only defines "basic Next.js app + common fixture setup".

   ```ts
   // tests/seed.spec.ts
   import { test, expect } from './fixtures';

   test('seed', async ({ page }) => {
     // Only verify that common fixtures / global setup are working correctly
   });
   ```

2. **App exploration + TODO document merging**

   - Based on the seed test, run the app and **actually explore the browser** to understand the DOM structure.
   - Based on the TODO document scenarios (Example: "when a guest user clicks like, a login modal appears"),

     - steps
     - expected results
       create an explicitly separated test plan.

3. **Write Markdown test plan**

- Output location: `specs/{feature-name}.md`
- Structure example (format based on official TodoMVC example):

```md
# /posts Detail Page - Like Feature Test Plan

## 1. Guest Like Flow

**Seed:** `tests/seed.spec.ts`
**Source TODO:** [Scenario 1] from `e2e/specs/post-detail.todo.md`

### Steps

1. Access `/posts` page as a guest user.
2. Click the first post card to navigate to the detail page.
3. Click the like button (heart icon).

### Expected Results

- A login prompt modal appears.
- The text `"Login is required for this feature."` is displayed in the modal.
- Like count / status does not change.
```

4. **Important Notes**

- planner **does not directly generate test code**.
- Assuming the app structure is unknown, do not hardcode locators,
  only express "what needs to be verified" in Markdown.
- You can optionally add new scenarios not in the TODO document, but
  in that case, leave a note like `Origin: planner-suggested` in the section.

---

## 4. Generator Agent Rules

### 4.1 Input

- `specs/*.md` (Markdown plan created by planner)
- seed test (`tests/seed.spec.ts`)
- `playwright.config.ts` from this repository

### 4.2 Output

- Playwright TypeScript test code
- Location: `e2e/tests/**.spec.ts`

Example: `specs/basic-operations.md` → `e2e/tests/posts/post-like-guest.spec.ts`

### 4.3 Code Writing Rules

#### 4.3.1 Basic Structure

```ts
// spec: specs/post-like.md
// seed: tests/seed.spec.ts

import { test, expect } from '../../fixtures/auth.fixtures';

test.describe('/posts/[id] - Like Feature', () => {
  test('Guest user sees login modal when clicking like', async ({ page }) => {
    // ...
  });

  test('Member user sees like count increase when clicking like', async ({ memberPage }) => {
    // ...
  });
});
```

- File name is a **feature + scenario** combination:

  - `/posts/[id]` like → `post-like-guest.spec.ts`, `post-like-member.spec.ts`, etc.

- Test names are taken almost directly from the TODO document scenarios, but refined slightly for clarity.

#### 4.3.2 Next.js & Navigation

- Route addresses are **never hardcoded**. Always fetch from constants file.

```ts
// From constants/routes.ts or similar file
import { ROUTES } from '@/constants/routes';

// Check if route is defined in constants
if (!ROUTES.POSTS) {
  throw new Error(
    'ROUTES.POSTS is not defined in constants. Please check the constants file.'
  );
}

await page.goto(ROUTES.POSTS);
```

- If route address is not in constants:

  - Notify the user without running the test.
  - Example: Error message like `"ROUTES.POSTS is not defined in constants. Please check the constants file."`

- Use `use.baseURL` from `playwright.config.ts` as much as possible.

- After page transitions:

  - `await page.waitForLoadState('networkidle')` **or**
  - Specific major element visibility assertion (`await expect(...).toBeVisible()`)
    stabilize first, then proceed with remaining verifications.

- **Do not use** `waitForTimeout` (causes flakiness).

#### 4.3.3 Screenshots / Videos / Traces

- Auto-capture configuration on failure in `playwright.config.ts`:

```ts
// playwright.config.ts
export default defineConfig({
  use: {
    screenshot: 'only-on-failure', // Auto-save screenshot on failure
    video: 'retain-on-failure', // Auto-save video on failure
    trace: 'retain-on-failure', // Auto-save trace on failure
  },
});
```

- Use Trace Viewer when debugging:

```bash
npx playwright test --trace on
npx playwright show-report
```

#### 4.3.4 Locator Strategy

> Follows best practices from official guides and MCP/Agents documentation.

Priority order:

1. `page.getByTestId(...)` — Top priority. Most stable and explicit.
2. `page.getByRole(...)` — Double as accessibility verification
3. `page.getByLabel(...)` — For form controls
4. `page.getByText(...)` — For non-interactive elements
5. CSS/XPath locator (`page.locator`) — Last resort

Example:

```ts
const firstPostCard = page.getByTestId('post-card').first();
const likeButton = page.getByRole('button', { name: /like/i });
const loginModal = page.getByRole('dialog', {
  name: /login is required for this feature/i,
});
```

List + Filter:

```ts
const postItem = page
  .getByRole('article')
  .filter({ hasText: 'First post title' });
```

#### 4.3.5 Assertions

- Use only web-first assertions (`await expect(...)`).

```ts
await expect(page.getByText('Login is required for this feature.')).toBeVisible();
await expect(likeButton).toBeEnabled();
```

- Do not use pattern of calling `.isVisible()` followed by synchronous `expect`.
- When multiple verifications are needed:

  - Critical results use hard assertions
  - Less important UI messages can use `expect.soft`.

#### 4.3.6 Login / Authorization

- **Prioritize reusing** existing fixtures / helpers. (Example: `auth.fixtures.ts`)
- If none exists, create new ones but with reusable names.

```ts
// e2e/fixtures/auth.fixtures.ts
import { test as base } from '@playwright/test';
import { ROUTES } from '@/constants/routes';

export const test = base.extend<{
  memberPage: (typeof base)['page'];
}>({
  memberPage: async ({ page }, use) => {
    if (!ROUTES.LOGIN) {
      throw new Error(
        'ROUTES.LOGIN is not defined in constants. Please check the constants file.'
      );
    }
    await page.goto(ROUTES.LOGIN);
    await page.getByLabel('Email').fill(process.env.E2E_USER_EMAIL!);
    await page.getByLabel('Password').fill(process.env.E2E_USER_PASSWORD!);
    await page.getByRole('button', { name: /sign in/ }).click();
    if (!ROUTES.HOME) {
      throw new Error(
        'ROUTES.HOME is not defined in constants. Please check the constants file.'
      );
    }
    await page.waitForURL(ROUTES.HOME);
    await use(page);
  },
});
```

#### 4.3.7 Functional Page Object Model (POM)

> **Note**: This section was inspired by [Toss Income's E2E Automation Journey](https://toss.tech/article/income-qa-e2e-automation).

**Core Principle**: Use **functional (Stateless) POM** instead of class-based POM.

- **Design page behavior with stateless functions instead of stateful classes**.
- Principle: Accept `page` (and optionally `context`) as input, return `page` as output.
- This avoids the complexity of `this` state management and inheritance structures, reducing maintenance costs.

**Before — Test written without POM (duplicate & fragile)**

```ts
// ❌ This code was copied across multiple files.
async function test1() {
  await page.goto(ROUTES.POSTS);
  await page.click('#category-selector');
  await page.click('button:has-text("All")');
  await page.click('button:has-text("Write")'); // If text changes, fix all files
  await page.fill('[placeholder="Enter title"]', 'Test title');
  // ...
}
```

**After — Encapsulated with functional POM**

```ts
// e2e/page-objects/post-list.page.ts
import { Page, BrowserContext } from '@playwright/test';
import { ROUTES } from '@/constants/routes';

/**
 * Navigate to the post list page and prepare the initial state.
 * @param page - Playwright Page object
 * @param context - BrowserContext (if needed)
 * @returns Prepared Page object
 */
export async function gotoPostListPage(
  page: Page,
  context?: BrowserContext
): Promise<Page> {
  if (!ROUTES.POSTS) {
    throw new Error('ROUTES.POSTS is not defined in constants.');
  }
  await page.goto(ROUTES.POSTS);
  await waitForNetworkIdleSafely(page);
  return page;
}

/**
 * Click the category button.
 * @param page - Playwright Page object
 * @param categoryName - Name of the category to select (e.g., "All", "Notice")
 */
export async function clickCategoryButton(
  page: Page,
  categoryName: string
): Promise<Page> {
  await clickButton(page, categoryName);
  await waitForNetworkIdleSafely(page);
  return page;
}

/**
 * Click the write button.
 * When the text changes, only this "one place" needs to be updated.
 */
export async function clickWriteButton(page: Page): Promise<Page> {
  await clickButton(page, 'Write');
  await waitForNetworkIdleSafely(page);
  return page;
}
```

**Tests read like "user scenarios"**

```ts
// e2e/tests/posts/post-write.spec.ts
import { test, expect } from '../../fixtures/auth.fixtures';
import {
  gotoPostListPage,
  clickCategoryButton,
  clickWriteButton,
} from '../../page-objects/post-list.page';

test('Member can write a post', async ({ memberPage }) => {
  let currentPage = await gotoPostListPage(memberPage);
  currentPage = await clickCategoryButton(currentPage, 'All');
  currentPage = await clickWriteButton(currentPage);
  // ...
});
```

**Naming Convention (Enhanced Readability)**

| Prefix                | Meaning           | Example                          |
| --------------------- | ----------------- | -------------------------------- |
| `goto`                | Navigate page     | `gotoPostListPage()`             |
| `click`               | Click             | `clickLikeButton()`              |
| `enter`               | Input             | `enterPostTitle()`               |
| `answer`              | Answer question   | `answerConfirmDialog()`          |
| `add`/`skip`/`update` | Data manipulation | `addComment()`, `skipOptionalStep()` |
| `verify`/`check`      | Verification      | `verifyPostCount()`              |
| `waitFor`             | Wait              | `waitForPostListReady()`         |
| `complete`            | Complex flow      | `completeLogin()`                |

**Split Files Based on User Scenarios**

When dividing files, use **user scenarios** as boundaries, not screens.

Example: Separate post creation flow step by step

```ts
e2e/page-objects/
├── post-list.page.ts        # List page (view, filter)
├── post-write.page.ts       # Write page (title, content input)
├── post-detail.page.ts      # Detail page (view, like, comment)
└── post-edit.page.ts        # Edit page (edit, save)
```

With this structure, even with frequent page transitions, responsibility boundaries are clear, and each step can be independently modified and reused.

**Robust Click Strategy — Resilient to Click Failures**

To reduce flakiness from React rendering timing, add a 4-step fallback strategy to the click utility.

```ts
// e2e/utils/click.utils.ts
import { Page } from '@playwright/test';

/**
 * Clicks a button robustly.
 * Uses a 4-step fallback strategy to minimize flakiness.
 *
 * @param page - Playwright Page object
 * @param buttonName - Text or aria-label of the button to click
 * @param options - Additional options
 * @returns Success status of the click
 */
export async function clickButton(
  page: Page,
  buttonName: string,
  options: { role?: 'button' | 'link' } = {}
): Promise<void> {
  const role = options.role || 'button';
  const button = page.getByRole(role, { name: buttonName });
  await button.waitFor({ state: 'visible' });

  try {
    // 1) Enter key (most stable)
    await button.focus();
    await page.keyboard.press('Enter');
  } catch {
    try {
      // 2) Normal click
      await button.click();
    } catch {
      try {
        // 3) Force click
        await button.click({ force: true });
      } catch {
        // 4) Direct JS execution
        await page.evaluate(
          ({ name, role }) => {
            const elements = Array.from(
              document.querySelectorAll(`${role}, [role="${role}"]`)
            );
            const btn = elements.find(
              (el) =>
                el.textContent?.includes(name) ||
                el.getAttribute('aria-label') === name
            ) as HTMLElement;
            btn?.click();
          },
          { name: buttonName, role }
        );
      }
    }
  }

  await waitForNetworkIdleSafely(page);
}
```

**Auto-detect Page Transitions — Safe with New Windows/Redirects**

When Next.js client-side navigation or external links open new windows or cause redirects, the original `page` may close. Standardize the pattern of always retrieving the latest valid page using a utility.

```ts
// e2e/utils/page.utils.ts
import { BrowserContext, Page } from '@playwright/test';

/**
 * Gets the latest valid page from the context.
 * Works safely even after new windows or redirects.
 *
 * @param context - BrowserContext
 * @param excludeUrls - URL patterns to exclude (e.g., ['scrape', 'popup'])
 * @returns Valid Page object
 */
export async function getLatestValidPage(
  context: BrowserContext,
  excludeUrls: string[] = []
): Promise<Page> {
  const pages = context.pages();
  for (let i = pages.length - 1; i >= 0; i--) {
    const p = pages[i];
    if (p.isClosed()) continue;

    const url = p.url();
    const shouldExclude = excludeUrls.some((pattern) => url.includes(pattern));
    if (!shouldExclude) return p;
  }
  throw new Error('No valid page found');
}

/**
 * Safely waits for network to stabilize.
 * Continues test even if timeout occurs.
 */
export async function waitForNetworkIdleSafely(
  page: Page,
  timeout: number = 5000
): Promise<void> {
  try {
    await page.waitForLoadState('networkidle', { timeout });
  } catch {
    // Continue even on timeout (network might not fully stabilize)
  }
}
```

In the test body, explicitly replace `currentPage = ...` on each transition to always operate on the correct tab.

```ts
test('Navigate to external link and back', async ({ page, context }) => {
  let currentPage = await gotoPostListPage(page);
  // Click external link (opens new window)
  await currentPage.getByRole('link', { name: 'External site' }).click();
  // Get latest valid page
  currentPage = await getLatestValidPage(context);
  await expect(currentPage).toHaveURL(/external-site/);
});
```

**How to Create Readable Tests**

1. **Start with Descriptive Titles**

   - Write tests with descriptive sentences from the start.
   - Example: `"Guest user sees login modal when clicking like"`

2. **Clarify Preconditions**

   - Preconditions should contain only minimal context like "user can log in", "can access post list".

3. **Write in Given-When-Then Structure**

   - Write scenarios in the rhythm of Given-When-Then.
   - Example: "When logged in (Given), clicking the first post in the list (When), then clicking like increases the count (Then)."

4. **Convert Natural Language to Code**
   - Transfer the scenario written in natural language directly to code.

```ts
test('Member sees like count increase when clicking like on a post', async ({
  memberPage,
}) => {
  // Given: Logged in and accessing post list page
  let currentPage = await gotoPostListPage(memberPage);

  // When: Click first post → navigate to detail page
  currentPage = await clickFirstPostCard(currentPage);

  // When: Click like button
  const initialCount = await getLikeCount(currentPage);
  await clickLikeButton(currentPage);

  // Then: Verify like count increased by 1
  await expect(currentPage.getByTestId('like-count')).toHaveText(
    String(initialCount + 1)
  );
});
```

The key is simple: **Tests read first, code follows.** Following this order makes tests understandable to non-developers and provides immediately executable scripts to developers.

---

## 5. Healer Agent Rules

### 5.1 Role

- Debug failing Playwright tests and automatically fix them when possible.
- Primary targets for fixes:

  - Changed locators (label name changes, button text changes, etc.)
  - Timing issues (unnecessary `waitForTimeout`, incorrect load conditions, etc.)
  - Minor data changes (text changes, count consistency, etc.)

### 5.2 Operation Sequence

1. Identify failing tests

   - Find failing cases through `mcp__playwright-test__test_list` / `test_run`, etc.

2. Re-run & UI Investigation

   - Re-run the failing point and use `browser_snapshot`, `browser_console_messages`, `browser_network_requests`, etc. to identify the cause.

3. Propose & Apply Patches

   - Update locators, remove unnecessary waits, fix assertion text, etc.,
     propose and apply patches that **only modify test code**.

4. Re-run and Report Results

   - After fixing, re-run tests to verify they pass.
   - If the feature itself is broken, do not force the test to "pass",
     leave it failing with comments/notes or convert to `test.skip`.

### 5.3 Prohibited Actions

- Do not modify actual app implementation code (Next.js pages/components/backend code).
- Do not switch to loose assertions (e.g., `toBeTruthy`) to force tests to pass, obscuring meaning.
- Do not ignore requirements from TODO documents / PRD, changing definitions with arbitrary behavior.

---

## 6. Common Testing Philosophy

> Summary of E2E / Playwright best practices emphasized across multiple resources and
> Functional POM philosophy learned from [Toss Income's E2E Automation Journey](https://toss.tech/article/income-qa-e2e-automation), adapted for this project.

1. **Verify only user-visible behavior.**

   - Do not overly depend on implementation details like deep DOM structure, internal state, API format, etc.

2. **Tests must be independent of each other (Test Isolation).**

   - Each test prepares its own required state (login, seed data).
   - Test isolation **increases reproducibility, makes debugging easier, and prevents cascading failures**.
   - Automate repetitive tasks before each test with `test.beforeEach()` hook, or
     reuse login state using setup projects.

3. **Allow some duplication, but abstract into helper/fixture when it becomes complex.**
4. **Make test names and file names immediately suggest "what is being verified".**
5. **Prioritize flakiness prevention.**

   - Solve timing issues with web-first assertion/locator strategies.
   - Use Robust Click Strategy (4-step fallback) to build resilience against click failures.

6. **Agents automate only test code.**

   - Business logic and domain rules always prioritize human-defined TODO documents / PRD.

7. **Functional POM: The way to overcome complexity is simplification and consistency.**

   - **Small functions and explicit context** are much stronger than inheritance and classes.
   - Frequently changing elements (text, selectors, wait logic) should be **managed in one place (POM/utilities)**.
   - Follow the principle of **always reassigning currentPage on page transitions**.
   - Avoid over-abstraction, opting for **clarity with small functions and explicit parameters**.

8. **Create readable tests.**

   - Write tests in Given-When-Then structure with descriptive titles.
   - Keep test body with **only business statements**, letting POM handle all buttons/selectors/wait logic.
   - Write code like documentation. Include JSDoc in all functions describing usage and cautions.

---

## 7. For Agents Reading This Document

1. Treat scenarios written by humans in `e2e/specs/*.todo.md` as the **source of truth**.
2. Follow the Playwright Test Agents workflow (planner → generator → healer), but
   always reference the rules defined in this document at each stage.
3. **Touch only test code, not app code.**
4. If there are ambiguous parts:

   - (In an interactive environment) Ask the user.
   - Otherwise, leave a `// TODO:` comment at the top of the test file and write with the most conservative assumption.

This guide establishes the standard for creating a test environment that can be
**driven all the way through** via Planner / Generator / Healer / MCP, with just TODO documents written.

---

## References

- [Toss Income Tax Refund Service: E2E Automation Journey to Maintain Quality at High Speed](https://toss.tech/article/income-qa-e2e-automation) (Suho Jeong, December 2, 2025)
  - Functional Page Object Model (POM) approach
  - Robust Click Strategy
  - How to write readable tests
  - Auto-detect page transitions
